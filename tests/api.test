package require tcltest
namespace import ::tcltest::*

#
# HELPER PROCS 
#
proc create_async {cDict} {
    set ::createAsync $cDict
}

proc exists_async {eDict} {
    set ::existsAsync $eDict
}

proc children_async {cDict} {
    set ::childrenAsync $cDict
}

proc set_async {sDict} {
    set ::setAsync $sDict
}

proc delete_async {dDict} {
    set ::deleteAsync $dDict
}

#
#
# CREATE
#
#
test create_sync {create a node and get its value} -body {
    set newNodeValue testingValueSync
    set newNodePath [file join / testCreateSync]
    zk create $newNodePath -value $newNodeValue

    return [zk get $newNodePath -version nodeVersion]
} -cleanup {
    zk delete $newNodePath $nodeVersion
} -result testingValueSync

test create_sync_null_data {create a node with no data} -body {
    set newNodeValue testingValueSync
    set newNodePath [file join / testCreateSyncNoData]
    zk create $newNodePath 

    return [zk get $newNodePath -version nodeVersion]
} -cleanup {
    zk delete $newNodePath $nodeVersion
} -result ""

test create_async {create a node using async and get its value} -body {
    set newNodeValue testingValueAsync
    set newNodePath [file join / testCreateAsync]
    zk create $newNodePath -value $newNodeValue -async create_async

    vwait ::createAsync
    return [dict get $::createAsync status]
} -cleanup {
    zk delete $newNodePath $nodeVersion
} -result ZOK

test create_node_twice_sync {
    create a node and then try to create it again
} -body {
    set newNodeValue createDup
    set newNodePath [file join / createDup]
    zk create $newNodePath -value $newNodeValue

    # try it again even though it already exists
    catch {zk create $newNodePath -value $newNodeValue} 
    puts $::errorCode
} -cleanup {
    zk delete $newNodePath -1
} -output "ZOOKEEPER ZNODEEXISTS {node exists}" -match regexp

test create_node_twice_async {
    create a node using async and then try to create it again
} -body {
    set newNodeValue createDup
    set newNodePath [file join / createDup]
    zk create $newNodePath -value $newNodeValue

    # try it again even though it already exists
    zk create $newNodePath -value $newNodeValue -async create_async
    vwait ::createAsync
    return [dict get $::createAsync status]
} -cleanup {
    zk delete $newNodePath -1
} -result ZNODEEXISTS

test create_ephemeral_node {
    create an ephemeral node, disconnect and verify that it no longer exists
} -body {
    set eNodePath [file join / createEphem]
    zk create $eNodePath -ephemeral

    zk destroy
    connect_to_zookeeper

    return [zk exists $eNodePath]
} -result 0

test create_sequential_node {
    create a sequential node and verify that it has the right number of digits
    which, according to the Zookeeper documentation, is 10, i.e., %010d
} -body {
    set sNodePath [file join / createSeq_]
    set sNodePath [zk create $sNodePath -sequence]
    
    set relativeName [lindex [file split $sNodePath] end]
    set numPart [lindex [split $relativeName _] end]
    return [string length $numPart]
} -cleanup {
    # create does not respect chroot when it is used
    # so have to compensate for this by being explicit 
    # in specifying the path of the node to delete
    zk delete [file join / $relativeName] -1
} -result 10

test create_numerous_sequential_nodes {
    create many sequential nodes and verify that they only exhibit
    monotonic sequence numbers
} -body {
    set sNodeBase [file join / createSeqs_]
    set seqNums [list]
    for {set i 0} {$i < 10} {incr i} {
	set sPath [zk create $sNodeBase -sequence -ephemeral]
	set sPath [lindex [file split $sPath] end]
	set seqNum [lindex [split $sPath _] end]
	lappend seqNums [scan $seqNum %d]
    }

    return [expr {$seqNums eq [lsort -integer $seqNums]}]
} -result 1

#
#
# EXISTS
#
#
test exists_created_node_sync {
    create a node and check for its existence in sync mode
} -body {
    set eNodePath [file join / createEphem]
    zk create $eNodePath 

    zk exists $eNodePath -version nodeVersion
} -cleanup {
    zk delete $eNodePath $nodeVersion
} -result 1

test exists_created_node_async {
    create a node and check for its existence in async mode
} -body {
    set eNodePath [file join / createEphem]
    zk create $eNodePath 

    zk exists $eNodePath -async exists_async 
    vwait ::existsAsync

    return [dict get $::existsAsync status]
} -cleanup {
    zk delete $eNodePath [dict get $::existsAsync version]
} -result ZOK

test exists_deleted_node_sync {
    check for the existence of a node that does not exist in sync mode
} -body {
    set eNodePath [file join / createEphem]
    zk create $eNodePath 
    zk delete $eNodePath -1

    # test several invocations of exists
    set e1 [zk exists $eNodePath -version nodeVersion]
    set e2 [zk exists $eNodePath -stat statArray]
    set e3 [zk exists $eNodePath]

    # if any of them return 1, this should fail
    return [expr {$e1 || $e2 || $e3}]
} -result 0

test exists_deleted_node_async {
    check for the existence of a node that does not exist in async mode
} -body {
    set eNodePath [file join / createEphem]
    zk create $eNodePath 
    zk delete $eNodePath -1

    zk exists $eNodePath -async exists_async 
    vwait ::existsAsync

    return [dict get $::existsAsync status]
} -result ZNONODE

#
#
# CHILDREN
#
#
test children_sync_normal {
    create several children in sync mode and test for their existence
} -body {
    set parentPath [file join / children]
    zk create $parentPath

    set children {0 1 2 3 4 5 6 7 8 9}
    foreach child $children {
	zk create [file join $parentPath $child]	
    }

    set zkChildren [lsort -integer [zk children $parentPath]]
    return [expr {$children eq $zkChildren}]
} -cleanup {
    foreach child $children {
	zk delete [file join $parentPath $child] -1
    }
} -result 1

test children_async_normal {
    create several children in async mode and test for their existence
} -body {
    set parentPath [file join / children]
    zk create $parentPath

    set children {0 1 2 3 4 5 6 7 8 9}
    foreach child $children {
	zk create [file join $parentPath $child]	
    }

    zk children $parentPath -async children_async
    vwait ::childrenAsync
} -cleanup {
    foreach child $children {
	zk delete [file join $parentPath $child] -1
    }
} -result 1

test children_sync_no_children {
    check for children in sync mode on a znode that has no children
}

test children_async_no_children {
    check for children in async mode on a znode that has no children
} 

#
#
# SET
#
#
test set_sync_normal {

}

test set_async_normal {

}

test set_sync_version_wrong {

}

test set_async_version_wrong {

}

test set_sync_madeup_znode {

}

test set_async_madeup_znode {

}

#
#
# DELETE
#
#
test delete_sync_normal {

}

test delete_async_normal {

}

test delete_sync_version_wrong {

}

test delete_async_version_wrong {

}

test delete_sync_madeup_znode {

}

test delete_async_madeup_znode {

}

cleanupTests

# vim: set ts=8 sw=4 sts=4 noet :
